<main><canvas id="root"></canvas></main>
<script defer>
  const STORAGE_KEY = "gems_storage";
  const MIN_VALID_QUEUE_COUNT = 3;

  const canvasScreenFactor = 0.9;
  const canvasEl = document.getElementById("root");
  let ctx = canvasEl.getContext("2d");

  const ITEMS_PACK = [
    {
      preview: "-",
      value: 0,
    },
    {
      preview: "+",
      value: 1,
    },
    {
      preview: "=",
      value: 3,
    },
    {
      preview: "*",
      value: 4,
    },
  ];
  const grid = {
    size: { x: 4, y: 5 },
  };
  const data = getData();

  function render(size, cells = []) {
    const {
      dimentions,
      cellSize,
      cellsTotalWidth,
      cellsTotalHeight,
      marginTop,
      marginLeft,
      lineWidth,
    } = getCanvasRenderinfo(size);

    canvasEl.setAttribute("width", dimentions.width);
    canvasEl.setAttribute("height", dimentions.height);

    ctx.fillStyle = "#e2e2e2";
    ctx.fillRect(0, 0, dimentions.width, dimentions.height);

    // console.info({
    //   cellSize,
    //   cellsTotalWidth,
    //   cellsTotalHeight,
    //   marginTop,
    //   marginLeft,
    // });

    drawLine(
      { x: marginLeft, y: marginTop },
      { x: marginLeft + cellsTotalWidth, y: marginTop }
    );
    drawLine(
      { x: marginLeft + cellsTotalWidth, y: marginTop },
      { x: marginLeft + cellsTotalWidth, y: marginTop + cellsTotalHeight }
    );
    drawLine(
      { x: marginLeft + cellsTotalWidth, y: marginTop + cellsTotalHeight },
      { x: marginLeft, y: marginTop + cellsTotalHeight }
    );
    drawLine(
      { x: marginLeft, y: marginTop + cellsTotalHeight },
      { x: marginLeft, y: marginTop }
    );

    for (let i = 0; i < size.x - 1; i++) {
      // draw vertical for each column
      const offset = (i + 1) * cellSize;
      drawLine(
        { x: marginLeft + offset, y: marginTop },
        { y: marginTop + cellsTotalHeight, x: marginLeft + offset }
      );
    }

    for (let i = 0; i < size.y - 1; i++) {
      // draw horizontal for each row
      const offset = (i + 1) * (cellSize + lineWidth);
      drawLine(
        { x: marginLeft, y: marginTop + offset },
        { y: offset + marginTop, x: marginLeft + cellsTotalWidth }
      );
    }

    // console.info(cells);
    cells?.forEach((item, index) => {
      const fontSize = cellSize / 2;
      const textOffset = cellSize / 2;
      const y = Math.floor(index / size.x);
      const x = index - y * size.x;

      const top = marginTop + y * cellSize + (textOffset + fontSize / 2);
      const left = marginLeft + x * cellSize + textOffset;

      // console.info({ item, x, y, left, top });
      ctx.fillStyle = "black";
      ctx.textAlign = "center";
      ctx.font = `${fontSize}px serif`;
      ctx.fillText(item?.preview || "", left, top);
    });
  }

  function getCanvasRenderinfo(size) {
    const dimentions = getCanvasDimentions();
    const cellSize = getCellSize(size, {
      width: dimentions.width * canvasScreenFactor,
      height: dimentions.height * canvasScreenFactor,
    });
    const lineWidth = 1;
    const cellsTotalWidth = cellSize * size.x;
    const cellsTotalHeight = cellSize * size.y;

    const marginTop = (dimentions.height - cellsTotalHeight) / 2;
    const marginLeft = (dimentions.width - cellsTotalWidth) / 2;

    return {
      dimentions,
      cellSize,
      cellsTotalWidth,
      cellsTotalHeight,
      marginTop,
      marginLeft,
      lineWidth,
    };
  }

  function getCellSize({ x, y }, { width, height }) {
    const xSize = width / x;
    const ySize = height / y;

    return Math.floor(Math.min(xSize, ySize));
  }

  function init() {
    console.info("init");
    let cells = data?.cells;

    if (!cells?.length) {
      cells = generateData(grid.size);

      saveData(Object.assign(data, { cells }));
    }

    render(grid.size, cells);
  }

  function generateData({ x, y }) {
    const cells = new Array(x * y)
      .fill(null)
      .map(() => generateRandomCell());

    return cells;
  }

  function getCanvasDimentions() {
    let height = window.innerHeight * canvasScreenFactor;
    let width = window.innerWidth * canvasScreenFactor;

    return { width, height };
  }

  function getCellIndexByCoords(x, y) {
    const {
      dimentions,
      cellSize,
      cellsTotalWidth,
      cellsTotalHeight,
      marginTop,
      marginLeft,
    } = getCanvasRenderinfo(grid.size);

    if (y < marginTop || y > marginTop + cellsTotalHeight) {
      console.warn(`Out of Y: ${y}`, getCanvasRenderinfo(grid.size));
      return -1;
    }

    if (x < marginLeft || x > marginLeft + cellsTotalWidth) {
      console.warn(`Out of X: ${x}`);
      return -1;
    }

    const row = Math.floor((y - marginTop) / cellSize);
    const col = Math.floor((x - marginLeft) / cellSize);

    let index = row * grid.size.x + col;
    let cell = data.cells[index];

    console.info(cell);
    return index;
  }

  function drawLine(from, to, color = "black") {
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.strokeStyle = color;
    ctx.stroke();
  }

  function getData() {
    const draftData = { cells: null };

    try {
      return JSON.parse(localStorage.getItem(STORAGE_KEY)) || draftData;
    } catch (err) {
      cosole.warn(`No data available!\n${err.message}`);
      return draftData;
    }
  }

  function saveData(data) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  // init();
  canvasEl?.addEventListener("click", (e) => {
    // console.log(e);
    const target = e.target;
    const index = getCellIndexByCoords(
      e.clientX - target.offsetLeft,
      e.clientY - target.offsetTop
    );

    if (index !== -1) {
      validate(index);
    }
  });

  function validate(cellIndex = 0) {
    const targetCell = data.cells[cellIndex];

    if (targetCell == null) {
      return;
    }

    // console.warn("validate");
    const validCellsQueueBelow = getValidQueue(
      targetCell,
      getCellsByDirection(cellIndex, grid.size, "down")
    );
    const validCellsQueueAbove = getValidQueue(
      targetCell,
      getCellsByDirection(cellIndex, grid.size, "up")
    );
    const validCellsQueueLeft = getValidQueue(
      targetCell,
      getCellsByDirection(cellIndex, grid.size, "left")
    );
    const validCellsQueueRight = getValidQueue(
      targetCell,
      getCellsByDirection(cellIndex, grid.size, "right")
    );
    const allQueues = [
      validCellsQueueAbove,
      validCellsQueueBelow,
      validCellsQueueLeft,
      validCellsQueueRight,
    ];

    const queuesSum = allQueues.reduce((res, arr) => res + arr.length, 0);
    const stackNum = queuesSum + 1;
    const isValidStack = stackNum >= MIN_VALID_QUEUE_COUNT;

    // console.log({
    //   targetCell,
    //   stackNum,
    //   isValidStack,
    //   validCellsQueueAbove,
    //   validCellsQueueBelow,
    //   validCellsQueueLeft,
    //   validCellsQueueRight,
    // });

    // TODO: Reduce turns num
    let targetCellIndexes = [];

    if (!isValidStack) {
      destroyCell(cellIndex);
      const eachAdjacent = getAdjacentCells(cellIndex, grid.size);
      // console.log(eachAdjacent);

      targetCellIndexes = eachAdjacent.reduce((res, item) => {
        return [...res, ...(item != null ? [item.index] : [])];
      }, []);
      console.warn("MISSED!", targetCellIndexes);
    } else {
      const allIndexes = allQueues.reduce((res, arr) => {
        return [...res, ...arr.map((it) => it.index)];
      }, []);

      targetCellIndexes = [cellIndex, ...allIndexes];
      console.info("Valid!", targetCellIndexes);
      // TODO: Add score
    }

    // targetCellIndexes.forEach((index) => destroyCell(index));
    targetCellIndexes.forEach((index) =>
      setCell(index, generateRandomCell(data.cells[index]?.value))
    );
  }

  function getValidQueue(targetCell, adjacentList) {
    const validQueue = [];

    for (let item of adjacentList) {
      const isValid =
        item.cell != null && item.cell.value === targetCell.value;

      if (isValid) {
        validQueue.push(item);
      } else {
        break;
      }
    }

    return validQueue;
  }

  function getCellsByDirection(fromIndex, gridSize, direction = "down") {
    let adjacentCell = getAdjacentCellByDirection(
      fromIndex,
      gridSize,
      direction
    );

    if (adjacentCell != null) {
      return [
        adjacentCell,
        ...getCellsByDirection(adjacentCell.index, gridSize, direction),
      ];
    }

    return [];
  }

  function getAdjacentCells(index, size) {
    return ["up", "down", "left", "right"].map((dir) =>
      getAdjacentCellByDirection(index, size, dir)
    );
  }

  function getAdjacentCellByDirection(
    targetCellIndex,
    gridSize,
    direction = "down"
  ) {
    const row = Math.floor(targetCellIndex / gridSize.x);
    const col = targetCellIndex - row * gridSize.x;
    let nextIndex = -1;

    switch (direction) {
      case "down": {
        if (row < gridSize.y - 1) {
          // row below
          nextIndex = targetCellIndex + gridSize.x;
        } else {
          // no row below
        }
        break;
      }
      case "up": {
        if (row > 0) {
          // row below
          nextIndex = targetCellIndex - gridSize.x;
        } else {
          // no row above
        }
        break;
      }
      case "left": {
        if (col < gridSize.x - 1) {
          // row below
          nextIndex = targetCellIndex + 1;
        } else {
          // no col to the left
        }
        break;
      }
      case "right": {
        if (col > 0) {
          // row below
          nextIndex = targetCellIndex - 1;
        } else {
          // no col to the right
        }
        break;
      }
    }

    if (nextIndex !== -1) {
      return { index: nextIndex, cell: data.cells[nextIndex] };
    }

    return null;
  }

  function destroyCell(index) {
    data.cells.splice(index, 1, null);
    saveData(data);
    render(grid.size, data.cells);
  }

  function setCell(index, cell) {
    data.cells.splice(index, 1, cell);

    saveData(data);
    render(grid.size, data.cells);
  }

  function generateRandomCell(prevValue = null) {
    const randIndex = Math.floor(Math.random() * ITEMS_PACK.length);

    const nextCell = Object.assign(
      { preview: "", value: null },
      ITEMS_PACK[randIndex]
    );

    if (prevValue == null || nextCell.value !== prevValue) {
      return nextCell;
    }

    return generateRandomCell(prevValue);
  }

  function reset() {
    let cells = generateData(grid.size);
    let newData = Object.assign(data, { cells });

    saveData(newData);
    init();
  }
</script>